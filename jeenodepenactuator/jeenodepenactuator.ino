// This one receives the zposition from the jeenodezdecoder
// there's a heartbeat generated by the jeenodezdecoder on digital pin 6
// (put an LED into it).  The actuator value goes out of pin 5 which is PWM
// On startup it cycles through 0 to 255 twice.  Then the first 
// Z value to come from the other jeenode is scaled to be at 500, 
// (then divided by 4 to be the midpoint of the actuator).

#include <XBee.h>
#include <Servo.h>

// If you're using a Mega, you can use different hardware serial ports for both the XBee and the logging.
// In that case (unless you're using an XBee shield), it's easiest to use Serial for logging, and Serial1 to talk to the XBee
// If you're using an Uno (or similar), which only has one hardware serial port, it's best to use Serial for the XBee
// and then SoftwareSerial (coupled to a USB-to-serial adapter) for logging

// Serial port used to communicate with the XBee module
#define XBEE  Serial

// Serial port used for logging
//#define LOG Serial
//#include "SoftwareSerial.h"
//SoftwareSerial gLogSerial(6, 7); // RX, TX
//#define LOG gLogSerial

#ifdef LOG
#define P(X) LOG.print(X)
#define PH(X) LOG.print(X, HEX)
#else
#define P(X)
#define PH(X)
#endif

XBee gXBee = XBee();
//Rx64Response gResponse = Rx64Response();
Rx16Response gResponse = Rx16Response();

Servo penservo; 

// Which Polargraph are we?
#define TOSCA
//#define KNUT

const uint32_t kToscaAddr = 0x40d9d49f;
const uint32_t kKnutAddr = 0x40d9d5cf;


const int payloadCount = 2; // the number of integers in the payload message
int payload[payloadCount];
int ledpin = 13; 
int actuatorpin = 5; 

int initialposition; 
bool binitialpositionset = false; 

long servolo = 20; 
long servohi = 160; 

long zlo = -100; 
long zhi = 10; 

void initialcycle(bool bshowactuate) 
{
    // initial flow through two cycles to see it move
    for (int i = 0; i < 2; i++) {
        P("actuate "); 
        P(i); 
        P("\r\n"); 
        for (int j = 50; j <= 200; j++) {
            if (bshowactuate)
                penservo.write(map(j, 50, 200, servolo, servohi)); 
            delay(5); 
            digitalWrite(ledpin, (((j/10) % 2) == 1 ? HIGH : LOW)); 
        }
        for (int j = 200; j >= 50; j--) {
            if (bshowactuate)
                penservo.write(map(j, 50, 200, servolo, servohi)); 
            delay(5); 
            digitalWrite(ledpin, (((j/10) % 2) == 1 ? HIGH : LOW)); 
        }
    }
    binitialpositionset = false; 
}


void setup() 
{
    XBEE.begin(9600);
    // Tell XBee to use Hardware Serial. It's also possible to use SoftwareSerial
    gXBee.setSerial(XBEE);

#ifdef LOG
    LOG.begin(9600);
#endif
    P("Let's go!\r\n");
    pinMode(ledpin, OUTPUT); 
    penservo.attach(actuatorpin); 
    
    //while (true) 
    initialcycle(true); 
}

#define htonl(x) ( ((x)<<24 & 0xFF000000UL) | \
                   ((x)<< 8 & 0x00FF0000UL) | \
                   ((x)>> 8 & 0x0000FF00UL) | \
                   ((x)>>24 & 0x000000FFUL) )
#define ntohl(x) htonl(x)

long zpos = 0; 
long prevzpos; 
int ncount = 0; 
long livecount = 1000; 
int ledtoggle; 
void loop() 
{
    gXBee.readPacket();
    
    if (gXBee.getResponse().isAvailable()) 
    {
        // got something      
        //if (gXBee.getResponse().getApiId() == RX_64_RESPONSE) 
        if (gXBee.getResponse().getApiId() == 0) //RX_16_RESPONSE) 
        {
            // got a rx packet
            gXBee.getResponse().getRx64Response(gResponse);
            //gXBee.getResponse().getRx16Response(gResponse);
            //option = gResponse.getOption();
            //data = gResponse.getData(0);
            // reset zero position 
            // (could use this to set the top and bottom range from a distance)
            P("len: ");
            int len = gResponse.getDataLength();
            P(len);
            P("\r\n");
            uint8_t* b = gResponse.getData();
            uint32_t* address = (uint32_t*)&b[1];
            int* payload = (int*)&b[6];
            int servopos;
#if 1
// Lots of logging
            if (ntohl(*address) == kToscaAddr)
            {
              P("Tosca packet => ");
            }
            if (ntohl(*address) == kKnutAddr)
            {
              P("Knut packet => ");
            }
            for (int i =0; i < len; i++)
            {
              if (b[i] < 0x10)
                P("0");
              PH(b[i]);
              P(" ");
            }
#endif
#ifdef TOSCA
            if (ntohl(*address) == kToscaAddr)
#else
            if (ntohl(*address) == kKnutAddr)
#endif
            {
              if (payload[1] == -998) 
              {
                  initialcycle(true); 
              }
              else if (payload[1] == -999) 
              {
                  initialcycle(false); 
              }
      
              zpos = payload[0]; 
              if (!binitialpositionset) {
                  initialposition = zpos; 
                  zlo = initialposition - 100; 
                  zhi = initialposition + 100; 
                  binitialpositionset = true; 
              }
              
              digitalWrite(ledpin, ((++ledtoggle) % 2 ? HIGH : LOW)); 
              servopos = map(constrain(zpos, zlo, zhi), zlo, zhi, servolo, servohi); 
              penservo.write(servopos); 
              livecount = 200000; 
            }

#if 1
            P(" Z: ");
            P(zpos);
            P(" Count: ");
            P(payload[1]); 
            P(" Servo: ");
            P(servopos); 
            P("\r\n");
#endif
        }
        else
        {
          P(gXBee.getResponse().getApiId());
          P(" Confused.\r\n");
        }
    } 
    else if (gXBee.getResponse().isError()) 
    {
        P("Error reading packet.  Error code: ");  
        P(gXBee.getResponse().getErrorCode());
        P("\r\n");
    }
    else
    {
        if (--livecount == 0) 
        {
            digitalWrite(ledpin, (ledtoggle % 2 ? LOW : HIGH)); 
            delay(100); 
            digitalWrite(ledpin, (ledtoggle % 2 ? HIGH : LOW)); 
            livecount = 200000; 
            P("overflow livecount\r\n"); 
        }
    }
}




